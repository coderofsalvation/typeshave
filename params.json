{"name":"TYPESHAVE!","tagline":"typesafe functions for PHP and Javascript","body":"<img src=\"https://camo.githubusercontent.com/c784f14f7c15fec9fa475bd2789be46d2cb96943/687474703a2f2f636f6465726f6673616c766174696f6e2e6769746875622e696f2f7479706573686176652f6c6f676f2e706e67\"/><br>\r\nWrap functions with typeshave to prevent functions doing garbage-in/garbage-out.\r\nValidate nested structures like a boss!\r\n\r\n## PHP BASICS\r\n\r\n    function foo($foo, $bar){\r\n      TypeShave::check( func_get_args(), (object)array( \r\n        \"foo\" => (object)array( \"type\" => \"string\" ),\r\n        \"bar\" => (object(array( \"type\" => \"integer\" )\r\n      ));\r\n      // do stuff with valid data\r\n    }\r\n\r\noh heck, we can just write jsonschema as well:\r\n\r\n    function foo($foo, $bar){\r\n      TypeShave::check( func_get_args(), '{\r\n        \"foo\": { \"type\": \"string\"  },\r\n        \"bar\": { \"type\": \"integer\" }\r\n      }');\r\n      // do stuff with valid data\r\n    }\r\n\r\n`TYPESHAVE` uses the established [jsonschema](http://jsonschema.net) validation-format, which allows extensive  nested data-validation.\r\nsee the composer module [here](https://packagist.org/packages/coderofsalvation/typeshave) or the github repo [here](https://github.com/coderofsalvation/typeshave.php)\r\n\r\n## NODEJS BASICS\r\n\r\n    COFFEESCRIPT                          JAVASCRIPT\r\n    ============                          ==========\r\n    foo = typesafe                        var foo = typesafe({\r\n      foo: { type: \"string\"  }              foo: { type: \"string\" }\r\n      bar: { type: \"integer\" }              bar: { type: \"integer\" }\r\n    , ( foo, bar ) ->                     }, function(foo, bar) {\r\n      console.log \"arguments are valid\"      return console.log(\"arguments are valid\");\r\n                                          });\r\n \r\n    foo(); // fail please!                foo(); // fail please!\r\n\r\n`TYPESHAVE` uses the established [jsonschema](http://jsonschema.net) validation-format, which allows extensive and nested datavalidation.\r\nSee the npm module [here](https://www.npmjs.com/package/typeshave)\r\n  \r\n## IN THE BROWSER\r\n\r\n    <script src=\"https://raw.githubusercontent.com/coderofsalvation/typeshave.js/master/browser/typeshave.min.js\"></script>\r\n    <script>\r\n      typeshave = require(\"typeshave\").typesafe;\r\n\r\n      var foo = typeshave({\r\n        foo: { type: \"string\" },\r\n        bar: { type: \"boolean\" }\r\n      }, function(foo,bar){\r\n        alert(\"ok data passed!\");\r\n      });\r\n\r\n      foo( \"string\", true );\r\n    </script>\r\n\r\n## Why non-typesafe is great, except with PHAT nested container-objects\r\n\r\nFor example:\r\n\r\n* REST payloads \r\n* objects which represent configs or options \r\n* datastructures and resultsets for html-rendering or processing purposes\r\n\r\nAre you still passing phat data around `fingers-crossed`-style?\r\nStill wondering why functions like this explode once in a while? :D\r\n\r\n    JS:  foo( { foo:\"bar\", bar: 123, records: [ 1, 2 ] } );\r\n    PHP: foo( (object)array( \"foo\"=>\"bar\", \"bar\"=>123, \"records\": array( 1, 2 )) );\r\n\r\nDid you you try PITA-fying your code with if/else checks?\r\n\r\n    JS: if( data == undefined data.bar == undefined || bar == undefined || Argh this is a big PITA \r\n    JS: // omg how do I even check properties recursively?\r\n    JS: // now finally we can do what the function should do :/\r\n\r\nand in PHP\r\n\r\n    PHP: function foo($data){\r\n    PHP:   if( isset($data)          && \r\n    PHP:       is_object($data)      && \r\n    PHP:       isset($data->foo)     && \r\n    PHP:       is_string($data->foo) &&\r\n    PHP:       .. \r\n    PHP:       && \r\n    PHP:       .. \r\n    PHP:       && Argh this is a big PITA \r\n    PHP:   // omg how do I even check properties recursively?\r\n    PHP:   foreach( $data->records as $record ){\r\n    PHP:     // PITA \r\n    PHP:     // PITA \r\n    PHP:     // PITA \r\n    PHP:   }\r\n    PHP:   ...\r\n    PHP:   // now finally we can do what the function should do :/\r\n    PHP: }\r\n\r\n`TYPESHAVE` and a simple jsonschema like this would validate the calls above easily:\r\n\r\n    {\r\n       \"type\": \"object\",\r\n       \"properties\": {\r\n          \"foo\": { \"type\": \"string\", \"enum\": [\"bar\",\"foo\"]   },\r\n          \"bar\": { \"type\": \"integer\", minimum:1, maximum:100 },\r\n          \"records\": {\r\n            \"type\": \"array\",\r\n            \"items\":[{\r\n              \"type\":\"integer\"\r\n            }]\r\n          }\r\n       }\r\n    }\r\n\r\n## More than typesafe\r\n\r\nJsonschema can do more than nested typechecking, check the [docs here](http://json-schema.org/documentation.html)\r\n\r\n    {\r\n      foo:{\r\n        type: \"string\",\r\n        enum: [\"simple\",\"advanced\",\"custom\"]    \r\n      },\r\n      bar:{\r\n        type: \"string\",\r\n        minLength: 1,\r\n        maxLength: 100,\r\n        regex: \"/[A-Za-z]/\"\r\n      }\r\n    }\r\n\r\n## Conclusion\r\n\r\nWith typeshave you can replace all that with one line of code.\r\nNo more :\r\n\r\n* functions going out of control\r\n* assertions-bloat inside functions \r\n* complaining about javascript not being typesafe\r\n* typesafe nested datastructures \r\n* verbose unittests doing typesafe stuff \r\n\r\nTypeshave deals with problems immediately when they occur to prevent this:\r\n\r\n<center><img src=\"http://www.gifbin.com/bin/102009/1256553541_exploding-trash.gif\"/></center>\r\n","google":"UA-66660972-1","note":"Don't delete this file! It's used internally to help with page regeneration."}